---
title: "Работа с БД"
description: "SQLite и CRUD"
sidebar:
  order: 7
---

**Цель**: изучить работу с SQLite и пагинацией.

## Подготовка

1. Повторите язык запросов SQL, изучите основы SQLite и работу с этой СУБД в node.js.

### Источники

1. [Шаблон репозиторий](https://softwarepatternslexicon.com/patterns-js/28/4/)
1. [Скачивание SQLite](https://www.sqlite.org/download.html)
1. [Введение в SQLite](https://metanit.com/sql/sqlite/1.1.php)
1. [SQLite Tutorial](https://www.sqlitetutorial.net/)
1. [SQLite Node.js](https://www.sqlitetutorial.net/sqlite-nodejs/)
1. [How To Use SQLite with Node.js on Ubuntu](https://www.digitalocean.com/community/tutorials/how-to-use-sqlite-with-node-js-on-ubuntu-22-04)
1. [Практическая шпаргалка SQL (SQLite) с готовыми запросами](https://habr.com/ru/articles/792630/)
1. [Node.js - Строка запроса](https://nodejsdev.ru/api/querystring/)

## Практика

### Создание БД

1. Продолжите работу на ветке из прошлого занятия и допишите новый функционал.
1. Установите пакет sqlite3 для интеграции с SQLite. Стоит ли пакет устанавливать как зависимость для разработки?
1. Создайте файл example.sql, в который поместите команды для создания таблиц names, comments и их наполнения. Само наполнение 3 пользователя и 9 комментариев (примерно по 3 на каждого пользователя). В таблице имен хранятся только имена, и они должны быть уникальны, в комментариях храниться текст комментария и время его добавления и связь с тем, кто его написал.
1. Используя утилиту sqlite3, создайте файл базы данных SQLite с именем comments.db в каталоге проекта. Этот файл стоит добавить в .gitignore.
1. Используя функцию .read() в утилите sqlite3 наполнить БД тестовыми данными.

### Связь БД и приложения

1. Добавить папку `repositories/`, в которой будут находиться файлы js с функциями для работы с БД.
1. POST-запрос на `/comments` теперь должен добавлять новый комментарий в БД, а не глобальную переменную. Требуется на стороне сервера добавить и информацию о времени добавления (timestamp). А в качестве ответа отправляется последний добавленный комментарий {id, имя, текст, время}.
1. GET-запрос на `/lastcomment.html` возвращает последний комментарий в виде html страницы, но требуется добавить информацию о времени добавления комментария.
1. GET-запрос на `/comments`, теперь должен уметь обрабатывать строки запросов URL, например `/comments?page=2&limit=5`.
   - Пагинация обычно включает в себя два ключевых параметра номер страницы (page): указывает конкретную страницу данных, которую необходимо получить. Каждая страница содержит подмножество всего набора данных. И количество на страницу (limit): указывает максимальное количество элементов для отображения на каждой странице.
   - Разберите входящий HTTP-запрос, чтобы извлечь параметры пагинации. В node.js для этой задачи есть модуль querystring.
   - Использовать эти параметры в сервисе для запроса к базе данных SQLite и извлечения соответствующего подмножества комментариев.
   - Отправить заданное количество комментариев клиенту в качестве ответа в формате JSON. Пример ответа ниже.

1. Модуль sqlite3 использует функции обратного вызова, для перехода на объекты promise можно использовать из модуля util функцию promisify.
1. Требуется обработать ошибки, которые могут возникнуть при работе с БД.

```json
{
    "page": 1,
    "limit": 10,
    "totalPages": 3,
    "comments": [
        {"id": 1, "comment": "Great work!", "name": "John Doe", "time": "2024-03-20T10:30:00Z"},
        {"id": 2, "comment": "Interesting article.", "name": "Jane Smith", "time": "2024-03-20T11:15:00Z"},
        ...
    ]
}
```

где,

- "page": Номер текущей страницы.
- "limit": Максимальное количество комментариев на странице.
- "totalPages": Общее количество страниц с учетом имеющихся комментариев и указанного ограничения.
- "comments": Массив, содержащий комментарии на странице, каждый из которых представлен в виде объекта с полями id, comment, name и time. "time": Временная метка, указывающая, когда был добавлен комментарий, отформатированная в ISO 8601.

### Тестирование

Добавить новые тесты в файл .http и протестировать весь функционал.

Также проведите нагрузочное тестирование, чтобы убедиться что нет радикальной деградации скорости работы сервера.

## Требования к коду и результат выполнения

- Код отформатирован, не содержит ошибок и замечаний от статического анализа кода ESLint, сохранен в системе контроля версий.
- Отсутствуют ошибки в консоли.
- Работающий локально сервер с логикой, которая соответствует требованиям задания.
- Сервер проходит все тесты.

## Вопросы для защиты (3 вопроса по 10 баллов)

1. Слой доступа к данным (DAL).
1. Шаблон репозиторий.
1. Пагинация и ее назначение.
1. Строка запроса (query string).
1. Время и ISO 8601.
1. SQL запросы на чтение данных с ограничениями, вставку данных.
1. SQL запросы для создания таблиц и связей в SQLite.
1. Основные типы данных в SQLite.